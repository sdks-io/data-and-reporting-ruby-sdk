# shell_data_reporting_ap_is
#
# This file was automatically generated by APIMATIC v2.0
# ( https://apimatic.io ).

module ShellDataReportingApIs
  # TransactionExceptionsRequest Model.
  class TransactionExceptionsRequest < BaseModel
    SKIP = Object.new
    private_constant :SKIP

    # Collecting Company Id of the selected payer. 
    # Optional if ColCoCode is passed else Mandatory.
    # Example:
    # 1 for Philippines
    # 5 for UK
    # @return [Integer]
    attr_accessor :col_co_id

    # Collecting Company Code  of the selected payer. 
    # Mandatory for serviced OUs such as Romania, Latvia, Lithuania, Estonia,
    # Ukraine etc. It is optional for other countries if ColCoID is provided.
    # Example:
    # 86 for Philippines
    # 5 for UK
    # @return [Integer]
    attr_accessor :col_co_code

    # Payer Id of the selected payer.
    # Optional if PayerNumber is passed else Mandatory
    # @return [Integer]
    attr_accessor :payer_id

    # Payer Number of the selected payer.
    # Optional if PayerId is passed else Mandatory
    # @return [String]
    attr_accessor :payer_number

    # Payer Number of the selected payer.
    # Optional if PayerId is passed else Mandatory
    # @return [Array[Accounts]]
    attr_accessor :accounts

    # Exceptions to be searched in transactions from date.
    # Should be with in last 24 months from the ToDate parameter.
    # Mandatory
    # Format: yyyyMMdd
    # @return [String]
    attr_accessor :transactions_from_date

    # Exceptions to be searched in transactions until date.
    # Mandatory. 
    # Format: yyyyMMdd
    # @return [String]
    attr_accessor :transactions_to_date

    # Value to be used on the Filter Condition
    # @return [Float]
    attr_accessor :value

    # Filter condition for the Exceptions.
    # Mandatory
    # 1. VolumeGreaterThan
    # 2. VolumeLessThan
    # 3. UsageGreaterThan
    # 4. UsageLessThan
    # 5. ValueGreaterThan (in Customer Currency)
    # 6. ValueLessThan  (in Customer Currency)
    # Note: - 
    # When “OutputType” = 1 is passed as input, above 3 and 4 Condition are not
    # applicable.
    # @return [Integer]
    attr_accessor :condition

    # Filter condition for the Exceptions.
    # Mandatory
    # 1. VolumeGreaterThan
    # 2. VolumeLessThan
    # 3. UsageGreaterThan
    # 4. UsageLessThan
    # 5. ValueGreaterThan (in Customer Currency)
    # 6. ValueLessThan  (in Customer Currency)
    # Note: - 
    # When “OutputType” = 1 is passed as input, above 3 and 4 Condition are not
    # applicable.
    # @return [Array[ExceptionProduct]]
    attr_accessor :products

    # Period in which the Exceptions such as Monthly/Weekly or Daily volume,
    # value or usage to be identified in the given transactions date range. It
    # is only applied when the Output Type is specified as "Cards".
    # Mandatory when Output Type is Cards
    # 1.    Month
    # 2.    Week
    # 3.    Day
    # 4.    Date Range
    # @return [Integer]
    attr_accessor :exception_period

    # Output Type for Exceptions.
    # Mandatory.
    # Possible values:
    # 1.    Transactions
    # 2.    Cards
    # @return [Integer]
    attr_accessor :output_type

    # True/False
    # Optional
    # Default value: False. 
    # When passed as ‘True’ Only returned records with Fuel transactions.
    # When passed as ‘False’ the above condition will not be checked.
    # @return [TrueClass | FalseClass]
    attr_accessor :fuel_only

    # SiteGroupIds to be applied to the Filter Condition.
    # Optional
    # When not passed, ignored.
    # When passed, transactions that are matching with the provided list of site
    # group id’s are only returned.
    # @return [Array[Integer]]
    attr_accessor :site_group_ids

    # True/False
    # Optional
    # Default value – False.
    # When set to True, the property names in the output will be replaced by
    # Field IDs.
    # @return [TrueClass | FalseClass]
    attr_accessor :use_field_id

    # A mapping from model property names to API property names.
    def self.names
      @_hash = {} if @_hash.nil?
      @_hash['col_co_id'] = 'ColCoId'
      @_hash['col_co_code'] = 'ColCoCode'
      @_hash['payer_id'] = 'PayerId'
      @_hash['payer_number'] = 'PayerNumber'
      @_hash['accounts'] = 'Accounts'
      @_hash['transactions_from_date'] = 'TransactionsFromDate'
      @_hash['transactions_to_date'] = 'TransactionsToDate'
      @_hash['value'] = 'Value'
      @_hash['condition'] = 'Condition'
      @_hash['products'] = 'Products'
      @_hash['exception_period'] = 'ExceptionPeriod'
      @_hash['output_type'] = 'OutputType'
      @_hash['fuel_only'] = 'FuelOnly'
      @_hash['site_group_ids'] = 'SiteGroupIds'
      @_hash['use_field_id'] = 'UseFieldId'
      @_hash
    end

    # An array for optional fields
    def self.optionals
      %w[
        col_co_id
        col_co_code
        payer_id
        payer_number
        accounts
        value
        products
        exception_period
        fuel_only
        site_group_ids
        use_field_id
      ]
    end

    # An array for nullable fields
    def self.nullables
      []
    end

    def initialize(transactions_from_date = nil, transactions_to_date = nil,
                   condition = nil, output_type = nil, col_co_id = SKIP,
                   col_co_code = SKIP, payer_id = SKIP, payer_number = SKIP,
                   accounts = SKIP, value = SKIP, products = SKIP,
                   exception_period = SKIP, fuel_only = SKIP,
                   site_group_ids = SKIP, use_field_id = SKIP)
      @col_co_id = col_co_id unless col_co_id == SKIP
      @col_co_code = col_co_code unless col_co_code == SKIP
      @payer_id = payer_id unless payer_id == SKIP
      @payer_number = payer_number unless payer_number == SKIP
      @accounts = accounts unless accounts == SKIP
      @transactions_from_date = transactions_from_date
      @transactions_to_date = transactions_to_date
      @value = value unless value == SKIP
      @condition = condition
      @products = products unless products == SKIP
      @exception_period = exception_period unless exception_period == SKIP
      @output_type = output_type
      @fuel_only = fuel_only unless fuel_only == SKIP
      @site_group_ids = site_group_ids unless site_group_ids == SKIP
      @use_field_id = use_field_id unless use_field_id == SKIP
    end

    # Creates an instance of the object from a hash.
    def self.from_hash(hash)
      return nil unless hash

      # Extract variables from the hash.
      transactions_from_date =
        hash.key?('TransactionsFromDate') ? hash['TransactionsFromDate'] : nil
      transactions_to_date =
        hash.key?('TransactionsToDate') ? hash['TransactionsToDate'] : nil
      condition = hash.key?('Condition') ? hash['Condition'] : nil
      output_type = hash.key?('OutputType') ? hash['OutputType'] : nil
      col_co_id = hash.key?('ColCoId') ? hash['ColCoId'] : SKIP
      col_co_code = hash.key?('ColCoCode') ? hash['ColCoCode'] : SKIP
      payer_id = hash.key?('PayerId') ? hash['PayerId'] : SKIP
      payer_number = hash.key?('PayerNumber') ? hash['PayerNumber'] : SKIP
      # Parameter is an array, so we need to iterate through it
      accounts = nil
      unless hash['Accounts'].nil?
        accounts = []
        hash['Accounts'].each do |structure|
          accounts << (Accounts.from_hash(structure) if structure)
        end
      end

      accounts = SKIP unless hash.key?('Accounts')
      value = hash.key?('Value') ? hash['Value'] : SKIP
      # Parameter is an array, so we need to iterate through it
      products = nil
      unless hash['Products'].nil?
        products = []
        hash['Products'].each do |structure|
          products << (ExceptionProduct.from_hash(structure) if structure)
        end
      end

      products = SKIP unless hash.key?('Products')
      exception_period =
        hash.key?('ExceptionPeriod') ? hash['ExceptionPeriod'] : SKIP
      fuel_only = hash.key?('FuelOnly') ? hash['FuelOnly'] : SKIP
      site_group_ids = hash.key?('SiteGroupIds') ? hash['SiteGroupIds'] : SKIP
      use_field_id = hash.key?('UseFieldId') ? hash['UseFieldId'] : SKIP

      # Create object from extracted values.
      TransactionExceptionsRequest.new(transactions_from_date,
                                       transactions_to_date,
                                       condition,
                                       output_type,
                                       col_co_id,
                                       col_co_code,
                                       payer_id,
                                       payer_number,
                                       accounts,
                                       value,
                                       products,
                                       exception_period,
                                       fuel_only,
                                       site_group_ids,
                                       use_field_id)
    end
  end
end
